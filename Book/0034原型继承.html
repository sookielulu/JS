<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>原型继承</title>
	<script type="text/javascript">
		// 1、原型继承
		// 如果需要让一个对象有某一个行为（属性、方法），那么可以考虑将这个行为加到原型对象中，
		// 那么这个对象就继承自原型对象，获得了该行为

		//如何使用原型对象
		// 1、利用对象的动态特性添加成员
		/**
		var o = {};
		o.name = "Jack";

		var Person = function () {};
		Person.prototype.sayHello = function () {
			alert("hahaha");
		};
		*/
		// 此时原型对象是对象，可以利用动态特性随时添加成员
		// 添加的成员都会被构造函数创建的对象所继承


		

		// 2、利用覆盖原型对象
		function Person () {};
		Person.prototype.sayHello = function () {
			alert("hahaha");
		};

		var p = new Person();
		console.log(p.constructor.name);// Person

		//Person.prototype.sayDoodbay = function () {};
		//Person.prototype.sayLove = function () {};
		//....

		//如果需要添加的内容非常多,就可以做整体替换
		Person.prototype = {
			//constructor: Person,
		 	sayHello: function () {},
		 	sayGoodbay: function () {},
		 	sayLove: function () {}
		};
		
		var p = new Person();
		console.log(p.constructor.name);// 若没有43行，则为Object; 有43行，则为Person
		//这里由Person创建出来的对象为什么是Object类型？
		//首先function Person () {};定义了构造函数，则默认就有prototype，默认的prototype就有constructor属性，
		//这个constructor属性指的就是构造函数，所以35行为Person。但是42行为整体替换prototype，原来的prototype
		//就不在了，则p.constructor在当前对象找constructor是找不到的(构造函数中没有定义)，所以就要去原型对象中找，
		//而原型对象被42行内容替换了，所以原型对象中也没有，所以就要去原型对象的原型对象中寻找，即为Object



		// 3、利用组合式继承添加原型成员
		//对象.extend(对象)
	</script>
</head>
<body>
	
</body>
</html>